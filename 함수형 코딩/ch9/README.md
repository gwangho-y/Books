## 챕터9 

### 패턴 2 추상화 벽
추상화 벽은 쉽게 말해 내가 사용하는 메서드의 세부내용을 알 필요 없다로 이해하면 쉬울거 같다.

예시)
마케팅 비즈니스 로직을 구현하는 팀과 
마케팅 함수의 세부 내용을 구현하는 데이터 로직이 짜는 팀이 있다고 했을 때,
마케팅 비즈니스 코드를 구현하는 팀에서는 데이터를 가지고 오는 팀에서 만든 코드를 끌어다 쓸 수 있다.
배열에서 특정 요소를 찾아주는 함수, 아이템을 집어 넣는 함수 등이 있을건데 함수의 이름과 필요한 인자 값을
넣으면 함수는 마케팅 팀에서 필요한 값을 리턴해준다.
즉, 마케팅 팀은 내가 사용하는 함수의 세부적인 내용을 몰라도 된다.

또한, 추상화 벽은 라이브러리나 API와 비슷하다고도 할 수 있겠다. 안에 있는 세부 내용은 내가 몰라도
필요한 값은 언제나 리턴 받을 수 있으니깐 말이다.

### 추상화 벽을 사용하기 좋은 시기
1. 쉽게 구현을 바꾸기 위해
   - 구현에 대한 확신이 없는 경우 추상화 벽을 사용하면 구현을 간접적으로 사용할 수 있기 때문에 나중에
   구현을 바구기 쉽다. 아직 확신이 없는 것을 구현해야할 때 코드를 수정하기는 훨씬 용이할거 같다.
2. 코드를 읽고 쓰기 쉽게 만들기 위해
   - 추상화 벽을 사용하면 세부적인 것을 신경쓰지 않아도 되고 이미 떨어져 있는 코드이기 때문에 어디서 
      에러가 났는지 더 찾기가 쉽다.
3. 팀 간에 조율해야 할 것을 줄이기 위해
   - 팀 간에 코드의 세부적인 내용은 몰라도 되고, 분리된 코드를 짜기 때문에 효율 적으로 일 할 수 있다.
4. 주어진 문제에 집중하기 위해
   - 이 부분이 추상화 벽의 진정한 가치라고 한다.
   - 추상화 벽은 코드가 나뉜 것이고 세부적인 코드 내용은 숨어있기 때문에 필요한 문제에 집중을 할 수 있다.

### 패턴 3 작은 인터페이스
작은 인터페이스 패턴은 새로운 코드를 추가할 위치에 관한 것.
인터페이스를 최소화하면 하위 계층에 불필요한 기능이 쓸데없이 커지는 것을 막을 수 있다.
 
예시) 마케팅 팀에서 특정 상품 할인에 대한 로직을 추가한다고 할 때,
1. 추상화 벽에 로직을 구현
2. 추상화 벽 위에 로직을 구현

주체는 마케팅 팀이므로 추상화 벽 위에 코드를 구현하는 것이 나을 것이다.
만약 추상화 벽 레벨에 코드를 구현한다면, 추상화 벽 관련 코드들을 만드는 팀이 관리를 하게 되거나,
비즈니스 로직이 추가가 되는 것이기 때문에 통일성이 없기 때문이다.

이 예제를 보고 생각이 든 것은 만약에 로직을 구현할 때, DB 단에 비즈니스 코드가 들어가는 것과 비슷하지 않을까?
하는 생각이 들었다.
쿼리문 안에 비즈니스 로직이 들어가면 관리가 어려워지고 에러를 쉽게 찾기 힘들듯이 어느 레벨에서
적절한 코드를 구현해야하는지에 대한 감을 어느정도 잡을 수 있었다.

### 패턴 4 편리한 계층
앞선 세가지 패턴을 사용해야할 때는 다음과 같다.
- 구체적인 것을 너무 많이 알아야 할 때,
- 코드가 지저분 하게 느껴질 때

편리한 계층을 사용할 수 있는 시기는?
- 설계와 새로운 기능의 필요성 사이 어느 지점에 머물게 되는때에 사용

#### 기능적 요구사항
소프트웨어가 정확히 해야 하는 일을 말한다.

#### 비기능적 요구사항 
유지보수성, 테스트성, 재사용성과 같은 소프트웨어를 설계할 때 중요한 것들.
우리가 지금까지 만든 코드들을 함수들을 호출 그래프로 표현하면 세가지 요구사항들에 답할 수 있다. 
1. 유지보수성 : 요구사항이 바뀌었을 때 가장 쉽게 고칠 수 있는 코드는 무엇인가?
2. 테스트성 : 어떤 것을 테스트하는게 가장 중요한가?
3. 재사용성 : 어떤 함수가 재사용하기 좋은가?


#### 그래프의 가장 위에 있는 코드가 고치기 쉽다.
비즈니스 로직처럼 자주 바뀌는 코드는 가장 위에 두고, 자주 변하지 않는 코드들은 계층의 아래에 둔다.
계층의 위에 있는 코드는 비즈니스 로직, 아래에 있는 코드는 장바구니 바뀌기, 배열 조작하기 등등이 있겠다.

상위에 있는 코드에서는 하위에 있는 코드를 사용하면 끝이지만 하위 코드 입장에서는 자기를 호출하는 상위코드가
세네가지가 있을 수 있기 때문에 고치기 골치아파진다.

따라서 시간이 지나도 변하지 않는 코드는 가장 아래 계층에 있어야 한다.

#### 아래에 있는 코드는 테스트가 중요하다.
적은 시간안에 테스트를 효율적으로 하려면??
- 가장 상위 기능을 테스트하면 자연스레 연관된 하위 기능들까지 테스트 가능하다.
신뢰성이 높은 테스트 방법은??
- 가장 하위 기능을 테스트하면 자주 호출되는 기능이기 때문에 신뢰성이 높다. 

하지만 가장 상위 코드는 자주 바뀌기 때문에 테스트가 오래 가지 않는다
그에 비해 하위 코드는 테스트는 거의 바뀌지 않고 사용되는 곳이 많기 때문에 테스트해서 얻는 것이 많다.


유지 보수성
위로 연결된 것이 적은 함수가 바꾸기 쉽다. -> 자주 바뀌는 코드는 위쪽에 존재해야한다.

테스트 가능성
위쪽으로 연결된 것이 많은 함수를 테스트 하는 것이 가치 있다. 
-> 아래 쪽에 있는 함수를 테스트하는 것이 위쪽에 있는 함수를 테스트하는 것보다 가치 있다.

재사용성
아래에 있는 함수가 적을수록 재사용하기 좋다.
-> 낮은 수준의 단계로 함수를 빼내면 재사용성이 더 높아진다.
