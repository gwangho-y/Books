## 챕터7

#### 방어적 복사
- 카피온라이트 원칙을 지키면서 안전하게 함수를 사용할 수 있는 원칙
- 데이터가 바뀌는 것을 완벽하게 막아주는 원칙
- 들어오고 나오는 데이터를 복사해서 사용한다.

### 방어적 복사는 원본이 바뀌는 것을 막아준다
만약 신뢰할 수 없는 코드가 데이터를 변경하고 있다면,
1. 코드에 들어가는 데이터를 복사한다.
2. 데이터를 코드에 주입한다.
3. 변경된 데이터를 복사한다.


신뢰할 수 없는 레거시 코드가 있다면, 방어적 복사로 코드를 감싼다.
```javascript
// 1차 복사
var cart_copy = deep_copy(shopping_cart)
black_friday_promotion(cart_copy) // 전역을 직접 변경하지 못하게 한다.
// 2차 복사 후 할당
shopping_cart = deep_copy(cart_copy)
```

### 방어적 복사 규칙

#### 규칙 1
1. 불변성 데이터를 위한 깊은 복사본을 만든다
2. 신뢰할 수 없는 코드로 복사본 전달


#### 규칙 2
1. 변경될 수도 있는 데이터가 들어오면 바로 깊은 복사본을 만들어 안전한 코드로 전달
2. 복사본을 안전한 코드에서 사용.


### 비공유적 아키텍쳐
모듈이 서로 통신할 때 방어적 복사를 구현했다면 이를 비공유적 아키텍쳐라고 한다.
모듈이 어떤 데이터의 참조도 공유하고 있지 않기 때문

### 카피온 라이트와 방어적 복사 비교
- 카피온 라이트
    
    언제? 통제할 수 있는 데이터를 바꿀 때 사용한다.
    
    어디서? 안전지대 어디서나 사용가능
    
    방식? 얕은 복사

    규칙
    1. 바꿀 데이터의 얕은 복사를 만든다
  2. 복사본을 변경
  3. 복사본을 리턴

- 방어적 복사

  언제? 신뢰할수 없는 코드와 데이터 주고 받을 때

  어디서? 안전지대 경계에서 데이터 오고갈 때

  방식? 깊은 복사

  규칙
    1. 안전지대로 들어오는 데이터에 깊은 복사를 만든다.
    2. 안전지대에서 나가는 데이터에 깊은 복사를 만든다.


### 요점
- 방어적 복사는 불변성을 구현하는 원칙
- 방어적 복사는 깊은 복사를 한다 비용이 많이든다
- 방어적 복사는 신뢰 불가능한 코드를 사용할 대만 사용
- 깊은 복사는 구조체 안에 있는 것들 모두를 복사, 얕은 복사는 필요한 부분만 최소한으로 복사.