## 챕터6
앞장에서는 엉켜 있는 설계를 풀면서 재사용 가능한 코드를 만들었다.
이번 장에서는 사용하는 데이터를 바꾸지 않고, 
불변형으로 만들어서 데이터의 변경점을 추적하기 쉬운 코드를 짜는걸 설명한다.

중첩된 데이터 : 배열이나 객체 안에 배열이나 데이터 있는 것.

### 동작은 읽고 쓰기 혹은 둘 다로 분류
읽기 : 데이터에서 정보를 가져오고, 변경 X
쓰기 : 데이터를 변경 O

ex)<br/> 
읽기 : 제품 이름 가져오기, 가격 가져오기 <br/>
쓰기 : 제품 추가, 제품 빼기, 수량 바꾸기

쓰기와 읽기 동작 모두 불변형으로 만들고 카피온라이트를 따라야한다.

### 카온 라이트 원칙 세단계
1. 복사본 만들기
2. 본사본 변경하기
3. 본사본 리턴하기

```javascript
function add_element_last(array, elem) {
    var new_array = array.slice() // 복사본 만들기
    new_array.push(elem) // 복사본 변경
    return new_array; // 복사본 리턴
}
```
카피온 라이트를 사용한다는 것은
쓰기 -> 읽기로 바꾼다는 것을 의미한다.

### 원래 버전과 카피 온 라이트 버전의 차이
p117

원래 버젼 : 쇼핑 카트를 직접 수정 <br/>
수정 버전 : 변경한 배열을 전역 변수에 할당

수정한 버전으로 값의 변경 시점을 용이하게 찾아낼 수 있다.

### 만약 읽고 쓰기 둘 다 하는 동작이 있다면
디스트럭쳐링 할당으로 둘 다 받을 수 있도록 만든다.

```javascript
function shift(array) {
    const array_copy = array.slice()
    const first = array_copy.shift()
    return {
        first : first,
        array : array_copy
    }
}

const { first, array } = shift(array)
```



### 불변 데이터 구조를 읽는 것은 계산

#### 변경 가능한 데이터를 읽은 것은 액션
변경 가능한 값을 읽을 때마다 다른 값을 읽을 수 있다.
변경 가능한 데이터를 읽은 것은 액션

#### 쓰기는 데이터를 변경 가능한 구조로 만든다
쓰기는 데이터를 바꾸기 때문에 데이터를 변경 가능한 구조로 만든다.

#### 어떤 데이터에 쓰기가 없다면 데이터는 변경 불가능한 데이터
쓰기를 모두 없앴다면 데이터는 생성 이루 변경 안 된다.

#### 불변 데이터 구조를 읽는 것은 계산
데이터가 불변형이라면 그 데이터의 모든 읽기는 계산

#### 쓰기를 읽기로 바꾸면 코드에 계산이 많아진다.
불변형을 만들수록 많은 계산이 생기고 액션이 줄어든다.

### 불변형으로 만들더라도 시간에 따라 상태 변경 가능하다
p132

우리는 데이터를 불변형으로 만드는 법을 배웠다.
하지만 모든 데이터가 불변형이면 프로그램의 시간에 따른 상태 값은 어떻게 변경하냐

```javascript
// 쓰기           바꾸기       읽기
shopping_cart = add_item(shopping_cart, shoes);
```
코드 처럼 메서드 자체에서 변경해서 던져주기 때문에 새 값으로 교체 가능하다.
즉, 시간에 따라 데이터를 변경 하는것도 가능하다.

### 중첩된 쓰기를 읽기로 바꾸기
중첩된 데이터 즉, 배열 이나 객체 안에 또다른 구조체가 있다면 이 역시
불변 데이터 구조로 변경을 해줘야한다. 최하위부터 최상위까지 중첩된데이터 구조의
모든 부분을 불변으로 바꿔줘야한다.

- 중첩데이터 : 데이터 구조 안에 데이터 구조가 있는 것. 안쪽, 최상위 데이터 존재
- 얕은 복사 : 중첩 데이터에서 최상위 데이터 구조만 복사
- 구조적 공유 : 두 중첩 데이터 구조에서 안쪽 데이터가 같은 데이터를 참조

#### 얕은 복사
```javascript
// 얕은 복사
let origin = ["a", "b", ["c"]];
let copy = origin.slice();

copy[2].push("d");

console.log(origin); //["a", "b", ["c", "d"]]; // 원본까지 바뀌어버림
console.log(copy); //["a", "b", ["c", "d"]];
// 이유는 중첩 배열인 2번째 배열은 메모리 주소만 복사했기 때문이다.
```

#### 깊은 복사
얕은 복사에서 안에 있는 구조체를 한번 더 복사


### 정리
- 함수형 프로그래밍에선 불변데이터를 사용. 쓰기 -> 읽기로 만든다
- 카피온라이트는 데이터를 불변형으로 유지. 원본대신 복사본 사용
- 카피 온 라이트는 값 변경 전에 얕은 복사, 리턴한다. 불변성 유지 가능
- 보일러플레이트 코드를 줄이기 위해 카피 온 라이트 메서드를 만드는게 중요